**Центральный процессор (CPU)** - электронный блок/интегральная схема, исполняющая машинные инструкции
**Состоит из:**
* блока управления (декодирует команды в микрооперации, дает другим частям процессора указания для выполнения команды и передает результаты в память)
* операционный блок (состоит из блоков, которые непосредственно выполняют какие-то операции: АЛУ, Integer Shifter, Integer Multiplier, FPU и другие)
* шины (набор параллельно связанных проводов, по которым передаются адоесаданных и сигналы управления)
* регистры данных (блоки памяти, лежащие прямо на кристалле процессора, с которой процесоор умеет взаимодействовать непосредственно)

## Регистры

Что касается регистров, то они делятся на два больших типа: программно доступные (те, к которым можно обратиться из выполняемой программы) и программно недоступные (например, EIP - счетчик команд, или EfLAGS -регистр состояния процессора). При этом, среди первых как правило существует деление на регистры общего назначения - использование которых строго не регламентировано ISA (общего назначения), и регистры, которые выполняют строго определенную функцию. Помимо этого этого существуют еще системные регистры, доступ к которым предоставляется программам в режиме ядра, а также специальные регистры, которые хранят системные данные для работы процессора (например, смещения базовых таблиц и уровни доступа)

В общем, классификация регистров немного бывает разной, но в целом классифицируют их по разным категориям. 
[Достаточный набор](https://en.wikipedia.org/wiki/Processor_register#Types)
Еще можно упомянуть, что процессор допускает обращение к нескольким регистрам (двум точно, насчет большего числа не уверен) как к одному. Например, если базовые регистры 32-битные, то для опрераций над 64-битными ISA может определять специальные имена регистров, при обращении к которым на самом деле будут рассматриваться два физических как единое целое. Возможна и обратная ситуация. Обращение к младшим битам регистра (обычно 32/16/8) осуществляется на архитектуре х86 через суффиксы D/W/B. То есть младшие биты регистра будут рассматриваться как отдельный регистр (возможно, бывает удобно, если хотим перейти в 32-битный режим или просто запустить 32-битную программу) [Про х86](https://metanit.com/assembler/tutorial/1.3.php)

Некоторые из регистров общего назначения: (названия приведены для архитектуры x86-32):
- EAX (Accumulator): для арифметических операций
- ECX (Counter): для хранения счетчика цикла
- EDX (Data): для арифметических операций и операций ввода-вывода
- EBX (Base): указатель на данные
- ESP (Stack pointer): указатель на верхушку стека
- EBP (Base pointer): указатель на базу стека внутри функции
- ESI (Source index): указатель на источник при операциях с массивом
- EDI (Destination index): указатель на место назначения в операциях с массивами
- EIP: указатель адреса следующей инструкции для выполнения
- EFLAGS: регистр флагов, содержит биты состояния процессора
Данные регистры характерны почти для любой архитектуры

## Шины
В стандартной архитектуре Фон Неймана определялись 3 вида шин для обмена между Процессором, памятью и системой ввода/вывода - адресная, управления и данных (названия, вероятно, говорящие) (тут наверное, нужно немного вспомнить Луцива, что передача может быть последовательной/параллельной и определяется ISA, но в данном контексте не так важно)

Устройство соединено с системной шиной (совокупность 3 вышеупомянутых):
* реагирует на сигналы шины управления "работа с устройством"
* проверяет значение на шине адреса на предмет совпадения с собственных идентификатором
* по команде читает/пишет с/на шину данных
* генерирует прерывание (если хочет) через шину управления

То есть достаточно просто: через шину управления мы передаем команды, через адресную - адрес/порт/устройство с которым взаимодействуем, через данных - просто конкретные байты данных
## Управляющий блок
Команды можно поделить на 2 типа: 
* регистр-память - извлечение слова из памяти и помещение его в регистр; далее используется в качестве входных данных для Операционного блока; аналогично в обратном порядке
* регистр-регистр - после операции в Операционном блоке результат может быть помещен в какой-то регистр (может быть стековую память, хотя по сути регистр) для дальнейшего использования
Последовательность команд регистр-регистр и операций в Операционном блоке называют трактом данных

Таким образом можно выделить следующие шаги обработки команды процессором:
1) Выборка команды (извлечение из памяти по адресу в PC, запись кода в IR; после этого обычно первое слово отправляется на дешифрацию, но если введены множественные команды, то их элементы дублируются для слева).
2) Определение адреса следующей команды (обычно на после, включая или команду, адрес слеж., индексацию, перескок в соседнее чтение; также производится услов. переход/безуслов. перескок, вызов подпрограммы и т. д.).
3) Дешифровка (что все из себя команда представляет? Какие действия нужны для выполнения? Какие регистры операндов и где их взять? Куда отправить результат?).
4) Выборка операндов (считывание и занесение операндов в регистры).
5) Исполнение 
6) Формирование признака результата (положительный/отрицательный/переполнение/ноль и тд).
7) Запись результата
## Микрокод и микрооперации
Микрокод - программа, реализующая набор инструкций процессора.
Микрооперации - система команд конкретной вычислительной машины, которая интерпретируется непосредственно процессором или микропрограммным уровнем.
То есть, в процессе каждая машинная инструкция реализуется в виде серии микроинструкций — микрокода.
Микрооперации состоят из серии микроинструкций —
элементарных операций, например, микропрограмма инструкции микропроцессора:
* Микроимпульсы (подача регистров АЛУ, сохранение в регистры).
* Настройка АЛУ на исполнение
* Ответ на код состояния и разрядов АЛУ
* сохранение операндов в регистры
* восстановление операндов в памяти

* При этом, как правило, микрокод хранится в специальной, быстродействующей памяти (control/store), обычно допускает только чтение и загружается при запуске процессора.
* Изначальной причиной использования микрокода было то, что так как он работает по принципу интерпретатора, позволяет разбить команду на элементарные операции, что делает машину проще в строении (замена аппаратной реализации программной); при росте набора инструкций становится сложнее реализовывать их в виде схем (то есть без использования микрокода).
* но, сложные команды работают медленнее через микрокод, чем чем аппаратную реализацию на схеме

Использование микропрограмм также смягчило проблему пропускной способности памяти. В 1970-х рост скорости процессора намного обгонял рост скорости памяти. Некоторые способы ускорения, такие как многоуровневые кэши, несколько смягчали проблему, но не решали её. Использование микрокода здесь очень помогло, поскольку меньшее количество более сложных инструкций требовало меньшего обмена с памятью. Например, если вся операция над строкой символов выполняется одной машинной инструкцией, то во время её выполнения не требуется выбирать из памяти другие инструкции.

Микрокод привел к идее семейств совместимых процессоров. Как правило строить большую схему дороже, чем реализовать ее программно. Но хотелось бы, чтобы какие-то команды (а значит и программы, в которых они есть) работали более-менее где-то еще, кроме как на конкретной модели компьютера. Одно из первых стало семейством на базе IBM System/360, включая более поздние микропрограммы в отдельных блоках (имплементация микропрограмм) через микрокод, а в других случаях – без него (на каких-то моделях команды имели аппаратную поддержку, а какие-то нет, но зато работало везде!)

## RISC/CISC

В 1970-е годы основной упор делался на решение проблемы, как заставить компьютер делать инструкции на уровне языка высокого уровня.
D. Patterson и C. Sequin были реализованы RISC I.
Было выяснено:
1) Многие сложные инструкции не используются в большинстве команд, генерируемых компилятором
2) алгоритмические эквивалентносты программ микрокода медленнее последовательности аппаратных простых операций

Главные усилия в архитектуре RISC направлены на построение максимально эффективного конвейера команд, то есть такого, где все команды извлекаются из памяти и поступают в ЦП на обработку в виде равномерного потока, причем ни одна команда не должна находиться в состоянии ожидания, а ЦП должен оставаться загруженным на протяжении всего времени.
Используются в процессорах [ARM](https://ru.wikipedia.org/wiki/ARM_\(%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0\)), [DEC Alpha](https://ru.wikipedia.org/wiki/DEC_Alpha), [SPARC](https://ru.wikipedia.org/wiki/SPARC), [AVR](https://ru.wikipedia.org/wiki/AVR), [MIPS](https://ru.wikipedia.org/wiki/MIPS_\(%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0\)), [POWER](https://ru.wikipedia.org/wiki/POWER) и [PowerPC](https://ru.wikipedia.org/wiki/PowerPC).

**Основные принципы RISC:**
1) Все команды выполняются аппаратным обеспечением (то есть без интерпретируемых микропрограмм) 
2) Компьютер должен запускать как можно больше команд в секунду (для этого требуется параллельное выполнение; но вообще этим можно плотно забить конвейер)
3) Легкое декодирование (как правило фиксированная длина инструкции, чтобы процесс декодировния проходил без этапов определения, закончилось ли чтение инструкции (как в случае переменной длины))
4) Все операции выполняются через регистры 
5) Для обращения к памяти выделены инструкции LOAD/STORE и только через них таковое происходит (в совокупности с пунктом 4 - нет сложных команд по типу - сложить что-то по адресу1 и что-то по адресу2 и записать весь результат в адрес3 - как одна команда)

**Основные принципы CISC:**
1. Произвольная длина команд.
2. Все арифметические действия в рамках операции в одной команде 
3. Ограниченное число строго определенных по функции, регистров
4. Нет конвейеризации по выполнению (тупо сложно)

Но это приводит к упрощению и оптимизации кода, что облегчает написание, плюс это уменьшает число обращений в память для загрузки следующих инструкций (что в 1970-е сильно ускоряло работу)

## Методы ускорения вычислений 

+ **Внеочередное исполнение** - выполнение инструкции не в порядке следования в машинном коде, а по мере готовности

	Порядок:
	1. считывание инструкции
	2. помещение инструкций в Очередь 1
	3. ожидание, когда операнды инструкций из Очереди станут доступны
	4. передача этой части, исполняемому модулю модулю
	5. выполнение
	6. запись результатов в Очередь 2
	7. извлечение из Очереди 2 результатов выполнения инструкций, перед которыми в Очереди 1 не осталось невыполненых инструкций и запись из в регистровый файл

+ **Спекулятивное выполнение** - выполнение инструкций заранее, в промежутки своюодного процессорного времени (удобно, чтобы не предсказывать переходы по ветвлению)
+ **Переименование регистров** - метод ослабления взаимодействия команд в процессорах с внеочередным исполнением
	В случае, если 2 или более команды необходимо осуществить доступ к данным в одном регистре, то невозможно их корректное внеочередное исполнение. В таком случае программные  ссылки на архитектурные регистры преобразуются в ссылки на физические регистры, что увеличивает колличество используемых регистров (процессор сам отслеживает зависимости)
+ **Объединение нескольких команд в одну**
+ **Предсказание переходов** - устройство в составе микропроцессора, которое имеет конвейерную архитектуру и определяет, будет ли выполнен условный переход
	1. статическое предсказание (предположим, что какая-то ветка выполняется всегда)
	2. динамическое предсказание (шаблоны, или счетчик/таблица зависимостей)
+ **Многоуровневое кэширование** (по идее, об этом в билете о памяти)
+ **Конвейер** (на это вообще отдельный билет)
+ **Суперскалярный процессор** – процессор, поддерж. параллелизм на уровне инструкций (т.е. выполнение неск. инструкций) за счёт включения в состав его вычислительного ядра нескольких функцион. узлов (ALU, FPU и др.)
	При этом планирование потока инструкций выполняется динамическим ядром
	Ограничения:
	+ степень параллелизма инструкций
	+ сложный поиск зависимотей
	+ обработка ветвления
	За порядком выполнения следит Instruction dispatcher:
	- чтение инструкции из памяти
	- определение, какие инструкции могут выполняться в след.
	- разбор инструк. между узлами

## Таксономия Флинна
_В целом, [викепедИя](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d0/MIMD-ru.svg/250px-MIMD-ru.svg.png) покрывает все необходимое_
Таксономия Флинна - это классификация компьютерных архитектур, которая была предложена Майклом Флинном в 1966 году. Она основана на количестве потоков инструкций и данных, которые могут быть обработаны процессором одновременно.

|                                                                                                   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| ------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ![](https://upload.wikimedia.org/wikipedia/commons/thumb/a/ac/SISD-ru.svg/1024px-SISD-ru.svg.png) | **SISD** (single instruction stream / single data stream) - одиночный поток команд и одиночный поток данных. К этому классу относятся, прежде всего, классические последовательные машины, или иначе, машины фон-неймановского типа, например, PDP-11 или VAX 11/780. В таких машинах есть только один поток команд, все команды обрабатываются последовательно друг за другом и каждая команда инициирует одну операцию с одним потоком данных. Не имеет значения тот факт, что для увеличения скорости обработки команд и скорости выполнения арифметических операций может применяться конвейерная обработка - как машина CDC 6600 со скалярными функциональными устройствами, так и CDC 7600 с конвейерными попадают в этот класс. |
| ![](https://upload.wikimedia.org/wikipedia/commons/thumb/3/38/SIMD-ru.svg/250px-SIMD-ru.svg.png)  | **SIMD** (single instruction stream / multiple data stream) - одиночный поток команд и множественный поток данных. В архитектурах подобного рода сохраняется один поток команд, включающий, в отличие от предыдущего класса, векторные команды. Это позволяет выполнять одну арифметическую операцию сразу над многими данными - элементами вектора. Способ выполнения векторных операций не оговаривается, поэтому обработка элементов вектора может производится либо процессорной матрицей, как в ILLIAC IV, либо с помощью конвейера, как, например, в машине CRAY-1.                                                                                                                                                              |
| ![](https://upload.wikimedia.org/wikipedia/commons/thumb/4/44/MISD-ru.svg/250px-MISD-ru.svg.png)  | **MISD** (multiple instruction stream / single data stream) - множественный поток команд и одиночный поток данных. Определение подразумевает наличие в архитектуре многих процессоров, обрабатывающих один и тот же поток данных. Однако ни Флинн, ни другие специалисты в области архитектуры компьютеров до сих пор не смогли представить убедительный пример реально существующей вычислительной системы, построенной на данном принципе. Ряд исследователей [3,4,5] относят конвейерные машины к данному классу, однако это не нашло окончательного признания в научном сообществе. Будем считать, что пока данный класс пуст.                                                                                                     |
| ![](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d0/MIMD-ru.svg/250px-MIMD-ru.svg.png)  | **MIMD** (multiple instruction stream / multiple data stream) - множественный поток команд и множественный поток данных. Этот класс предполагает, что в вычислительной системе есть несколько устройств обработки команд, объединенных в единый комплекс и работающих каждое со своим потоком команд и данных.                                                                                                                                                                                                                                                                                                                                                                                                                         |

